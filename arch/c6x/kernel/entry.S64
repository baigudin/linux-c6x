;
;  linux/arch/c6x/kernel/entry.s
;
;  Port on Texas Instruments TMS320C6x architecture
;
;  Copyright (C) 2004, 2005, 2006, 2009, 2010 Texas Instruments Incorporated
;  Author: Aurelien Jacquiot (aurelien.jacquiot@virtuallogix.com)
;  Updated for 2.6.34: Mark Salter <msalter@redhat.com>
;  
;  This program is free software; you can redistribute it and/or modify
;  it under the terms of the GNU General Public License version 2 as
;  published by the Free Software Foundation.
;

		.include	"c6x_defs.inc"
		.include	"c6x_config.inc"

	;; Registers naming
DP			.set	B14
FP			.set	A15
SP			.set	B15
	
	;; Constants
INT_SYSCALL		.set	6	; interrupt used for system call

	.if (CONFIG_TMS320C64X == 1)
HAVE_32_REGS .set 1
	.elseif (CONFIG_TMS320C64XPLUS == 1)
HAVE_32_REGS .set 1
	.else
HAVE_32_REGS .set 0
	.endif

	.if (CONFIG_PREEMPT == 0)
	.asg restore_all,resume_kernel
	.endif

	;; Entry management functions
		.def 	resume
		.def 	ret_from_exception
		.def 	ret_from_interrupt

	;; Interrupt handlers
		.def 	_int4_handler
		.def 	_int5_handler
		.def 	_int7_handler
		.def 	_int8_handler
		.def 	_int9_handler
		.def 	_int10_handler
		.def 	_int11_handler
		.def 	_int12_handler
		.def 	_int13_handler
		.def 	_int14_handler
		.def 	_int15_handler
		.def	_bad_interrupt
		.def	_nmi_handler

	;; Syscalls
		.def 	sys_fork
		.def	sys_clone
		.def 	sys_execve

	;; External functions
		.ref	schedule
		.ref	schedule_tail
		.ref	syscall_trace_entry
		.ref	syscall_trace_exit
		.ref	send_sig
		.ref	do_notify_resume
		.ref	c6x_do_IRQ
		.ref 	c6x_fork
		.ref	c6x_clone
		.ref	c6x_vfork
		.ref	c6x_execve
		.ref 	do_sigsuspend
		.ref	do_sigreturn
		.ref	do_rt_sigreturn
		.ref	sys_rt_sigsuspend
		.ref	exit
		.ref	do_exit
		.ref	init_thread_union
		.ref	sys_pread64
		.ref	sys_pwrite64
		.ref	sys_truncate64
		.ref	sys_ftruncate64
		.ref	sys_fallocate
		.if (CONFIG_PREEMPT == 1)
		.ref	preempt_schedule_irq
		.endif

	;; External variables
		.ref	irq_stat
		.ref	_edata

	;; Internal variables
		.def	_sys_call_table

	;;
	;;  This defines the normal kernel pt_regs layout.
	;;
SAVE_ALL	.macro	__rp,__tsr
	STW	B0,*SP--[2]		; save original B0
	MVKL	current_ksp,B0
	MVKH	current_ksp,B0
	LDW	*B0,B1			; KSP

	NOP	3
	STW	B1,*+SP[1]		; save original B1
	XOR	SP,B1,B0		; (SP ^ KSP)
	LDW	*+SP[1],B1		; restore B0/B1
	LDW	*++SP[2],B0
	SHR	B0,KTHREAD_SHIFT,B0	; 0 if already using kernel stack

  [B0]	STDW.D2	SP:DP,*--B1[1]		; user: save user sp/dp on kernel stack
  [B0]	MV	B1,SP			;    and switch to kernel stack
||[!B0] STDW.D2	SP:DP,*--SP[1]		; kernel: save on current stack

	SUBAW	SP,2,SP

	.if	(HAVE_32_REGS == 1)
	SUB	SP,8,A15
 ||	STDW.D2	A15:A14,*SP--[16]	; save A15:A14
 	.else
	SUB	SP,8,A15
 ||	STDW.D2	A15:A14,*SP--[8]	; save A15:A14
	.endif

	STDW.D2	B13:B12,*SP--[1]
 ||	STDW.D1	A13:A12,*A15--[1]
 ||	MVC.S2	__rp,B13

	STDW.D2	B11:B10,*SP--[1]
 ||	STDW.D1	A11:A10,*A15--[1]
 ||	MVC.S2	CSR,B12

	.if	(CONFIG_TMS320C64XPLUS == 1)
	STDW.D2	B9:B8,*SP--[1]
 ||	STDW.D1	A9:A8,*A15--[1]
 ||	MVC.S2	RILC,B11
	STDW.D2	B7:B6,*SP--[1]
 ||	STDW.D1	A7:A6,*A15--[1]
 ||	MVC.S2	ILC,B10
	.else
	STDW.D2	B9:B8,*SP--[1]
 ||	STDW.D1	A9:A8,*A15--[1]
	STDW.D2	B7:B6,*SP--[1]
 ||	STDW.D1	A7:A6,*A15--[1]
	.endif

	STDW.D2	B5:B4,*SP--[1]
 ||	STDW.D1	A5:A4,*A15--[1]

	STDW.D2	B3:B2,*SP--[1]
 ||	STDW.D1	A3:A2,*A15--[1]
 ||	MVC.S2	__tsr,B5

	STDW.D2	B1:B0,*SP--[1]
 ||	STDW.D1	A1:A0,*A15--[1]
 ||	MV	B5,A5

	.if	(HAVE_32_REGS == 1)
	STDW.D2	B31:B30,*SP--[1]
 ||	STDW.D1	A31:A30,*A15--[1]
	STDW.D2	B29:B28,*SP--[1]
 ||	STDW.D1	A29:A28,*A15--[1]
	STDW.D2	B27:B26,*SP--[1]
 ||	STDW.D1	A27:A26,*A15--[1]
	STDW.D2	B25:B24,*SP--[1]
 ||	STDW.D1	A25:A24,*A15--[1]
	STDW.D2	B23:B22,*SP--[1]
 ||	STDW.D1	A23:A22,*A15--[1]
	STDW.D2	B21:B20,*SP--[1]
 ||	STDW.D1	A21:A20,*A15--[1]
	STDW.D2	B19:B18,*SP--[1]
 ||	STDW.D1	A19:A18,*A15--[1]
	STDW.D2	B17:B16,*SP--[1]
 ||	STDW.D1	A17:A16,*A15--[1]
	.endif

	STDW.D2	B13:B12,*SP--[1]	; save PC and CSR

	.if	(CONFIG_TMS320C64XPLUS == 0)
	STW.D2	A4,*SP--[2]		; orig A4
	.else
	STDW.D2	B11:B10,*SP--[1]	; save RILC and ILC
	STDW.D2	A5:A4,*SP--[1]		; save TSR and orig A4
	.endif

	;; We left an unused word on the stack just above pt_regs.
	;; It is used to save whether or not this frame is due to
	;; a syscall. It is cleared here, but the syscall handler
	;; sets it to a non-zero value.
	MVK	0,B1
	STW	B1,*+SP(REGS__END+8)	; clear syscall flag
	.endm

SAVE_ALL_EXCEPT	.macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	SAVE_ALL IRP
	.else
	SAVE_ALL NRP,NTSR
	.endif
	.endm

SAVE_ALL_INT	.macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	SAVE_ALL IRP
	.else
	SAVE_ALL IRP,ITSR
	.endif
	.endm

RESTORE_ALL	.macro	__rp,__tsr

	.if	(CONFIG_TMS320C64XPLUS == 1)
	LDDW	*++SP[1],B9:B8			; get TSR (B9)
	LDDW	*++SP[1],B11:B10		; get RILC (B11) and ILC (B10)
	LDDW	*++SP[1],B13:B12		; get PC (B13) and CSR (B12)
	.else
	LDDW	*++SP[2],B13:B12		; get PC (B13) and CSR (B12)
	.endif

	.if	(HAVE_32_REGS == 1)
	ADDAW	SP,30,A15
	.else
	ADDAW	SP,14,A15
	.endif

	.if	(HAVE_32_REGS == 1)
	LDDW.D1	*++A15[1],A17:A16
 ||	LDDW.D2	*++SP[1],B17:B16
	LDDW.D1	*++A15[1],A19:A18
 ||	LDDW.D2	*++SP[1],B19:B18
	LDDW.D1	*++A15[1],A21:A20
 ||	LDDW.D2	*++SP[1],B21:B20
	LDDW.D1	*++A15[1],A23:A22
 ||	LDDW.D2	*++SP[1],B23:B22
	LDDW.D1	*++A15[1],A25:A24
 ||	LDDW.D2	*++SP[1],B25:B24
	LDDW.D1	*++A15[1],A27:A26
 ||	LDDW.D2	*++SP[1],B27:B26
	LDDW.D1	*++A15[1],A29:A28
 ||	LDDW.D2	*++SP[1],B29:B28
	LDDW.D1	*++A15[1],A31:A30
 ||	LDDW.D2	*++SP[1],B31:B30
	.endif

	LDDW.D1	*++A15[1],A1:A0
 ||	LDDW.D2	*++SP[1],B1:B0

	.if	(HAVE_32_REGS == 1)
	LDDW.D1	*++A15[1],A3:A2
 ||	LDDW.D2	*++SP[1],B3:B2
 ||	MVC	B9,__tsr
	LDDW.D1	*++A15[1],A5:A4
 ||	LDDW.D2	*++SP[1],B5:B4
 ||     MVC	B11,RILC
	LDDW.D1	*++A15[1],A7:A6
 ||	LDDW.D2	*++SP[1],B7:B6
 ||	MVC	B10,ILC
	.else
	LDDW.D1	*++A15[1],A3:A2
 ||	LDDW.D2	*++SP[1],B3:B2
	LDDW.D1	*++A15[1],A5:A4
 ||	LDDW.D2	*++SP[1],B5:B4
	LDDW.D1	*++A15[1],A7:A6
 ||	LDDW.D2	*++SP[1],B7:B6
	.endif

	LDDW.D1	*++A15[1],A9:A8
 ||	LDDW.D2	*++SP[1],B9:B8
 ||	MVC	B13,__rp

	LDDW.D1	*++A15[1],A11:A10
 ||	LDDW.D2	*++SP[1],B11:B10
 ||	MVC	B12,CSR

	LDDW.D1	*++A15[1],A13:A12
 ||	LDDW.D2	*++SP[1],B13:B12

	MV	A15,SP
 ||	MVKL	current_ksp,A15
	MVKH	current_ksp,A15
 ||	ADDAW	SP,6,A14
	STW	A14,*A15		; save kernel stack pointer

	LDDW.D2	*++SP[1],A15:A14

	B	__rp			; return from interruption
	LDDW.D2	*+SP[1],SP:DP
	NOP	4
	.endm

RESTORE_ALL_EXCEPT	.macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	RESTORE_ALL IRP
	.else
	RESTORE_ALL NRP,NTSR
	.endif
	.endm

RESTORE_ALL_INT	.macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	RESTORE_ALL IRP
	.else
	RESTORE_ALL IRP,ITSR
	.endif
	.endm	

MASK_SYSCALL  .macro tmp
	.if	(CONFIG_TMS320C64XPLUS == 0)
	MVC.S2	IER,B1
	CLR.S2	B1,INT_SYSCALL,INT_SYSCALL,B1
	MVC.S2	B1,IER
	.endif
	.endm

UNMASK_SYSCALL  .macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	MVC.S2	IER,B1
	SET.S2	B1,INT_SYSCALL,INT_SYSCALL,B1
	MVC.S2	B1,IER
	.endif
	.endm

MASK_INT  .macro reg
	MVC.S2	CSR,reg
	CLR	reg,0,0,reg
	MVC.S2	reg,CSR
	.endm

	;; Enable interrupts
UNMASK_INT	.macro	reg
	MVC	CSR,reg
	SET	reg,0,0,reg
	MVC	reg,CSR
	.endm


RESTORE_NK_INT	.macro

	MVC.S2	CSR,B2
	CLR	B2,0,0,B2
	MVC.S2	B2,CSR			; cut global IRQ

	.if	(CONFIG_NK == 1)
	.ref    irq_IER
	MVC.S2	IER,B4
	MVKL.S2	irq_IER,B2
	MVKH.S2	irq_IER,B2
	LDW.D2	*B2,B2
	NOP	4
	OR.L2	B2,B4,B4		; enable IT set in irq_IER
	MVC.S2	B4,IER
	.endif
	.endm

	.if	(CONFIG_TMS320C64XPLUS == 0)
SWITCH_STACK_SIZE 	.set	(12*4+8)
	.else
SWITCH_STACK_SIZE 	.set	(14*4+8)
	.endif

	;;
	;; Save remaining registers preserved by C
	;; B3 must contain the return addresse
	;;
SAVE_SWITCH_STACK	.macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	STW.D2	B3,*SP--[12]		; push return address
	STDW.D2	B13:B12,*+SP[5]
	STDW.D2	B11:B10,*+SP[4]
	STDW.D2	A15:A14,*+SP[3]
	STDW.D2	A13:A12,*+SP[2]
	STDW.D2	A11:A10,*+SP[1]
	.else
	STW.D2	B3,*SP--[14]		; push return address
	STDW.D2	B13:B12,*+SP[6]
	STDW.D2	B11:B10,*+SP[5]
	STDW.D2	A15:A14,*+SP[4]
	STDW.D2	A13:A12,*+SP[3]
 ||	MVC.S2  RILC,B11
	STDW.D2	A11:A10,*+SP[2]
 ||	MVC.S2  ILC,B10
	STDW.D2	B11:B10,*+SP[1]
	.endif
	.endm

RESTORE_SWITCH_STACK	.macro
	.if	(CONFIG_TMS320C64XPLUS == 0)
	LDDW.D2	*+SP[1],A11:A10
	LDDW.D2	*+SP[2],A13:A12
	LDDW.D2	*+SP[3],A15:A14
	LDDW.D2	*+SP[4],B11:B10
	LDDW.D2	*+SP[5],B13:B12
	LDW.D2	*++SP[12],B3		; pop return address
	.else
	LDDW.D2	*+SP[1],B11:B10		; load B11 (RILC ) and B10 (ILC)

	LDDW.D2	*+SP[2],A11:A10
	LDDW.D2	*+SP[3],A13:A12
	LDDW.D2	*+SP[4],A15:A14
	LDDW.D2	*+SP[5],B11:B10

	LDDW.D2	*+SP[6],B13:B12
 ||	MVC.S2	B10,ILC

 	LDW.D2	*++SP[14],B3		; pop return address
 ||	MVC.S2	B11,RILC
	.endif
	NOP		4
	.endm

	;;
	;; Call c6x_do_IRQ with the corresponding int number and regs
	;;
CALL_INT	.macro int
	MVK.S1	int,A4
 ||	ADD	8,SP,B4
	MVKL	c6x_do_IRQ,A0
	MVKH	c6x_do_IRQ,A0
	BNOP	A0,3
	MVKL	ret_from_interrupt,B3
	MVKH	ret_from_interrupt,B3
	.endm

GET_THREAD_INFO	.macro reg
	SHR	SP,KTHREAD_SHIFT,reg
	SHL	reg,KTHREAD_SHIFT,reg
	.endm

	.sect 	".data"

	.global	current_ksp
current_ksp:
	.word	init_thread_union + KTHREAD_START_SP

	.sect 	".text"

	;;
	;; Jump to schedule() then return to ret_from_exception
	;;
_reschedule:
	MVKL	schedule,A0
	MVKH	schedule,A0
	BNOP	A0,3
	MVKL	ret_from_exception,B3
	MVKH	ret_from_exception,B3

	;;
	;; Called before syscall handler when process is being debugged
	;;
tracesys_on:

	MVKL	syscall_trace_entry,A0
	MVKH	syscall_trace_entry,A0
	B	A0
	ADDKPC	ret_from_syscall_trace,B3,3
	ADD	SP,8,A4

ret_from_syscall_trace:
	;; tracing returns (possibly new) syscall number
	MV	A4,B0

 || 	MVKL	sys_ni_syscall,A0
 || 	MVK	NR_SYSCALLS_,B1
	CMPLTU	B0,B1,B1
 ||	MVKH	sys_ni_syscall,A0

 [!B1]	B	A0
 [!B1]	ADDKPC	ret_from_syscall_trace,B3,4

	;; reload syscall args from (possibly modified) stack frame
	LDW	*+SP(REGS_B4+8),B4
	LDW	*+SP(REGS_A6+8),A6
	LDW	*+SP(REGS_B6+8),B6
	LDW	*+SP(REGS_A8+8),A8
	LDW	*+SP(REGS_B8+8),B8

	;; Get syscall handler addr from _sys_call_table:
	MVKL	_sys_call_table,B1
	MVKH	_sys_call_table,B1
	LDW	*+B1[B0],B0		; B0 = _sys_call_table[__NR_*]
	MVKL	ret_from_syscall_function,B3
	MVKH	ret_from_syscall_function,B3
	NOP	2
	B	B0			; branch to syscall handler
	LDW	*+SP(REGS_ORIG_A4+8),A4
	NOP	4


syscall_exit_work:
	AND	_TIF_SYSCALL_TRACE,A2,A0
 [!A0]	BNOP	work_pending,5
 [A0]	B	syscall_trace_exit
	ADDKPC	resume_userspace,B3,1
	MVC	CSR,B1
	SET	B1,0,0,B1
	MVC	B1,CSR		; enable ints

work_pending:
	AND	_TIF_NEED_RESCHED,A2,A0
 [!A0]	BNOP	work_notifysig,5

work_resched:
	MVKL	schedule,A1
	MVKH	schedule,A1
	B	A1
	ADDKPC	work_rescheduled,B3,4
work_rescheduled:
	;; make sure we don't miss an interrupt setting need_resched or
	;; sigpending between sampling and the rti
	MASK_INT B2
	GET_THREAD_INFO A12
	LDW	*+A12(THREAD_INFO_FLAGS),A2
	MVK	_TIF_WORK_MASK,A1
	MVK	_TIF_NEED_RESCHED,A3
	NOP	2
	AND	A1,A2,A0
 ||	AND	A3,A2,A1
 [!A0]	BNOP	restore_all,5
 [A1]	BNOP	work_resched,5

work_notifysig:
	B	do_notify_resume
	LDW	*+SP(REGS__END+8),A6 ; syscall flag
	ADDKPC	resume_userspace,B3,1
	ADD	SP,8,A4		; pt_regs pointer is first arg
	MV	A2,B4		; thread_info flags is second arg

ret_from_exception:
	.if (CONFIG_PREEMPT == 1)
	MASK_INT B2
	.endif
	;;
	;; On C64x+, the return way from exception and interrupt
	;; is a little bit different
	;;
ret_from_interrupt:
	.if	(CONFIG_TMS320C64XPLUS == 0)

	;;
	;; Check if we are comming from user mode.
	;; C6x doesn't have a user/supervisor mode
	;; so we need to compare context stack and
	;; current one (ksp).
	;;
	LDW	*+SP(REGS_SP+8),B0
	MVKL	resume_kernel,A0
	MVKH	resume_kernel,A0
	NOP	2
	XOR	B0,SP,B0
	SHR	B0,KTHREAD_SHIFT,B0	; (SP ^ KSP) >> KTHREAD_SHIFT => User or Sup

	.else

	;;
	;; Check if we are comming from user mode.
	;;
	LDW	*+SP(REGS_TSR+8),B0
	MVK	0x40,B1
	MVKL	resume_kernel,A0
	MVKH	resume_kernel,A0
	NOP	1
	AND	B0,B1,B0

	.endif

 [!B0]	BNOP	A0,5

resume_userspace:
	;; make sure we don't miss an interrupt setting need_resched or
	;; sigpending between sampling and the rti
	MASK_INT B2
	GET_THREAD_INFO A12
	LDW	*+A12(THREAD_INFO_FLAGS),A2
	MVK	_TIF_WORK_MASK,A1
	MVK	_TIF_NEED_RESCHED,A3
	NOP	2
	AND	A1,A2,A0
 [A0]	BNOP	work_pending,5
	BNOP	restore_all,5

	;;
	;; System call function (called by syscall int)
	;; B0 = syscall number (in _sys_call_table)
	;; A4,B4,A6,B6,A8,B8 = arguments of the syscall function
	;; A4 is the return value register
	;; 
	.if	(CONFIG_TMS320C64XPLUS == 0)
	.def 	_system_call
_system_call:
	SAVE_ALL_EXCEPT			; save A0-A9/B0-B9 registers in stack
	MASK_SYSCALL
	.endif

system_call_saved:
	MVK	1,B2
	STW	B2,*+SP(REGS__END+8)	; set syscall flag
	.if	(CONFIG_TMS320C64XPLUS == 1)
	MVC.S2	B2,ECR		        ; acknowledge the software exception
	.endif

	UNMASK_INT B2			; re-enable global IT

system_call_saved_noack:
	;; Check system call number
	MVK	NR_SYSCALLS_,B1
 || 	MVKL	sys_ni_syscall,A0
	CMPLTU	B0,B1,B1
 || 	MVKH	sys_ni_syscall,A0

 [!B1]	B	A0
 [!B1]	ADDKPC	ret_from_syscall_function,B3,4

	;; Get syscall handler addr from _sys_call_table:	
	MVKL	_sys_call_table,B1
	MVKH	_sys_call_table,B1
	LDW	*+B1[B0],B0		; B0 = _sys_call_table[__NR_*]

	;; Check for ptrace
	GET_THREAD_INFO A12
	LDW	*+A12(THREAD_INFO_FLAGS),A2
	NOP	4
	AND	_TIF_SYSCALL_TRACE,A2,A2 ; check for TIF_SYSCALL_TRACE flag
 [A2]	BNOP	tracesys_on,5		; call syscall_trace_entry before syscall function

	;; Branch to the corresponding syscall
	B	B0
	ADDKPC	ret_from_syscall_function,B3,4

ret_from_syscall_function:
	STW	A4,*+SP(REGS_A4+8)	; save return value in A4
					; original A4 is in orig_A4
syscall_exit:
	;; make sure we don't miss an interrupt setting need_resched or
	;; sigpending between sampling and the rti
	MASK_INT B2

	;; Disable IT
	.if	(CONFIG_NK == 1)
	.ref    irq_IER

	MVC.S2	IER,B4
	MVKL.S2	irq_IER,B2
	MVKH.S2	irq_IER,B2
	LDW.D2	*B2,B2
	NOP	4
	ANDN.L2	B4,B2,B4
	MVC.S2	B4,IER			; change IER

	UNMASK_INT B2
	.endif

	LDW	*+A12(THREAD_INFO_FLAGS),A2
	MVKL	syscall_exit_work,A0
	MVKH	syscall_exit_work,A0
	MVK	_TIF_ALLWORK_MASK,A1
	NOP
	AND	A1,A2,A2 ; check for work to do
 [A2]	BNOP	syscall_exit_work,5

restore_all:
	RESTORE_ALL_EXCEPT

	;;
	;; After a fork we jump here directly from resume,
	;; so that A4 contains the previous task structure.
	;;
	.def 	ret_from_fork
ret_from_fork:
	MVKL	schedule_tail,A0
	MVKH	schedule_tail,A0
	B	A0
	ADDKPC	ret_from_fork_2,B3,4
ret_from_fork_2:
	;; return 0 for child process
	MVK	0,B0
 ||	MVKL	syscall_exit,B1
	STW	B0,*+SP(REGS_A4+8)
 ||	MVKH	syscall_exit,B1
	BNOP	B1,5

	;;
	;; These are the interrupt handlers, responsible for calling __do_IRQ()
	;; int6 is used for syscalls (see _system_call entry)
	;;
_int4_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 4

_int5_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 5

	.if	(CONFIG_TMS320C64XPLUS == 1)
	.def	_int6_handler 
_int6_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 6
	.endif

_int7_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 7

_int8_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 8

_int9_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 9

_int10_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 10

_int11_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 11

_int12_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 12

_int13_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 13

_int14_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 14

_int15_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 15

	.if	(CONFIG_NK == 1)
	.def 	_xirq_handler
_xirq_handler:
	SAVE_ALL_INT
	MASK_SYSCALL
	CALL_INT 5
	.endif

	;;
	;; Handler for uninitialized and spurious interrupts
	;;
_bad_interrupt:
	B	IRP
	NOP	5

	;;
	;; Handler for NMI (C6x) and exceptions (C64x+)
	;;
_nmi_handler:
	.if	(CONFIG_TMS320C64XPLUS == 0)

	B	NRP
	NOP	5

	.else

	.ref	process_exception

	SAVE_ALL_EXCEPT

	MVC.S2	EFR,B2
 	CMPEQ   B2,1,B2
 ||	MVC.S2	TSR,B1
 	MV	B2,A2
 ||	CLR	B1,10,10,B1
	MVC.S2	B1,TSR
 [!A2]	MVKL	process_exception,A0
 ||[B2]	MVKL	system_call_saved,B1
 [!A2]	MVKH	process_exception,A0
 ||[B2]	MVKH	system_call_saved,B1
 [!B2]	B	A0
 [B2]   B	B1
 [!B2]  ADDAW	SP,2,B1
 [!B2]	MV	B1,A4
 	ADDKPC	ret_from_trap,B3,2

ret_from_trap:
	MV	A4,B0
 [!B0] 	MVKL	ret_from_exception,B3
 [!B0] 	MVKH	ret_from_exception,B3
 [!B0]	BNOP	B3,5

	MVKL	system_call_saved_noack,B3
	MVKH	system_call_saved_noack,B3

	LDW	*+SP(REGS_B0+8),B0
	LDW	*+SP(REGS_A4+8),A4
	LDW	*+SP(REGS_B4+8),B4
	LDW	*+SP(REGS_A6+8),A6
	LDW	*+SP(REGS_B6+8),B6
	LDW	*+SP(REGS_A8+8),A8
 ||	B	B3
	LDW	*+SP(REGS_B8+8),B8
	NOP	4
	.endif

	;;
	;; Jump to schedule() then return to ret_from_isr
	;;
irq_reschedule:
	MVKL	schedule,A0
	MVKH	schedule,A0
	BNOP	A0,3
	MVKL	ret_from_interrupt,B3
	MVKH	ret_from_interrupt,B3
	NOP	3

	.if (CONFIG_PREEMPT == 1)
resume_kernel:
	GET_THREAD_INFO A12
	LDW	*+A12(THREAD_INFO_PREEMPT_COUNT),A1
	MVKL	restore_all,A0
	MVKH	restore_all,A0
	NOP	2
 [A1]	BNOP	A0,5

preempt_schedule:
	GET_THREAD_INFO A2
	LDW	*+A2(THREAD_INFO_FLAGS),A1
	MVKL	restore_all,A0
	MVKH	restore_all,A0
	MVKL	preempt_schedule_irq,B0
	MVKH	preempt_schedule_irq,B0
	AND	_TIF_NEED_RESCHED,A1,A1	; check for TIF_NEED_RESCHED flag
 [!A1]	BNOP	A0,5
	B	B0
	ADDKPC	preempt_schedule,B3,4
	.endif

	.if	(CONFIG_TMS320C64XPLUS == 1)
	.def    enable_exception
enable_exception:
	DINT
	MVC	TSR,B0
	MVC	B3,NRP
	MVK	0xc,B1
	OR	B0,B1,B0
	MVC	B0,TSR			;  Set GEE and XEN in TSR
	B	NRP
	NOP	5
	.endif

	;;
	;; Special system calls
	;; return address is in B3
	;;
sys_fork:
	ADD	8,SP,A4
 ||	MVKL	c6x_fork,A0		; branch to _c6x_fork(struct pt_regs *regs)
	MVKH	c6x_fork,A0
	BNOP	A0,5

sys_clone:
	ADD	SP,8,A4
 ||	MVKL	c6x_clone,A0
	MVKH	c6x_clone,A0
	BNOP	A0,5

sys_vfork:
	ADD	8,SP,A4
 ||	MVKL	c6x_vfork,A0		; branch to _c6x_vfork(struct pt_regs *regs)
	MVKH	c6x_vfork,A0
	BNOP	A0,5

sys_sigsuspend:
	ADD	8,SP,A4
 ||	MVKL	do_sigsuspend,A0	; branch to _do_sigsuspend
	MVKH	do_sigsuspend,A0
	BNOP	A0,5

sys_rt_sigsuspend_wrapper:
	ADD	8,SP,A4
 ||	MVKL	sys_rt_sigsuspend,A0	; branch to sys_rt_sigsuspend
	MVKH	sys_rt_sigsuspend,A0
	BNOP	A0,5

sys_sigreturn:
	ADD	8,SP,A4		; move to A4 the starting value of pt_regs
 ||	MVKL	do_sigreturn,A0	; branch to _do_sigreturn
	MVKH	do_sigreturn,A0
	BNOP	A0,5

sys_rt_sigreturn:
	ADD	8,SP,A4			; move to A4 the starting value of pt_regs
 ||	MVKL	do_rt_sigreturn,A0	; branch to _do_rt_sigreturn
	MVKH	do_rt_sigreturn,A0
	BNOP	A0,5

sys_execve:
	ADDAW	SP,2,B6			; put regs addr in 4th parameter
					; & adjust regs stack addr
	LDW 	*+SP(REGS_B4+8),B4

	;; c6x_execve(char *name, char **argv, char **envp, struct pt_regs *regs)
 ||	MVKL	c6x_execve,A0
	MVKH	c6x_execve,A0
	B	A0
	STW	B3,*SP--[2]
	ADDKPC	ret_from_c6x_execve,B3,3

ret_from_c6x_execve:
	LDW	*++SP[2],B3
	NOP	4
	BNOP	B3,5

sys_pread_c6x:
	MVKL	sys_pread64,A0
	MVKH	sys_pread64,A0
	BNOP	A0,4
	MV	A8,B7

sys_pwrite_c6x:
	MVKL	sys_pwrite64,A0
	MVKH	sys_pwrite64,A0
	BNOP	A0,4
	MV	A8,B7

sys_truncate64_c6x:
	MVKL	sys_truncate64,A0
	MVKH	sys_truncate64,A0
	BNOP	A0,4
	MV	A6,B5

sys_ftruncate64_c6x:
	MVKL	sys_ftruncate64,A0
	MVKH	sys_ftruncate64,A0
	BNOP	A0,4
	MV	A6,B5

;; On Entry
;;   A4 - fd
;;   B4 - mode
;;   A6 - offset_hi
;;   B6 - offset_lo
;;   A8 - len_hi
;;   B8 - len_lo
sys_fallocate_c6x:
	MVKL	sys_fallocate,A0
	MVKH	sys_fallocate,A0
	BNOP	A0,1
 	MV	A6,A7
 	MV	B6,A6
	MV	A8,B7
	MV	B8,B6

	;;
	;; resume() switchs to a new task
	;; A4 = prev task
	;; B4 = next task
	;; A6 = thread offset
	;; B6 = shared flags (mm structure is shared between tasks)
	;;
resume:
	ADD	A6,A4,A0		; ptr to thread struct
 ||	MVC	CSR,B2
	STW	B2,*+A0(THREAD_CSR)	; save CSR

	;; Save non-scratch registers on stack
	SAVE_SWITCH_STACK

	;; Save current kernel stack pointer
	MV	SP,A2
	STW	A2,*+A0(THREAD_KSP)

	;; Get pointer to thread struct (B4 contains the new task)
 ||	ADD	A6,B4,B4

	;; Restore the kernel stack pointer
	LDW	*+B4(THREAD_KSP),B2
 	MVKL	current_ksp,B1
	MVKH	current_ksp,B1
	NOP	2
	MV	B2,SP
 ||	STW	B2,*B1

	;; Restore non-scratch registers
	RESTORE_SWITCH_STACK

	;; Restore status register
	LDW	*+B4(THREAD_CSR),B2
	BNOP	B3,4			; return in next E1
	MVC	B2,CSR

	;;
	;; void * current_text_addr(void)
	;; Return current PC
	;;
	.global current_text_addr
current_text_addr:
	BNOP	B3,3
	MVC	PC,B4
	MV	B4,A4

	;;
	;; unsigned int get_current(void):
	;; Return current process
	;;
	.global	__current_thread_info
__current_thread_info:
	BNOP	B3,3
	CLR	SP,0,KTHREAD_SHIFT-1,B4
	MV	B4,A4

	;;
	;; unsigned int get_sp(void):
	;; Return current SP
	;;
	.global	get_sp
get_sp:
	BNOP	B3,4
	MV	SP,A4

	;;
	;; void set_sp(unsigned int sp):
	;; Set current SP
	;;
	.global	set_sp
set_sp:
	BNOP	B3,4
	MV	A4,SP

	;;
	;; System calls table
	;;
SYSCALL_ENTRY .macro handler
	.ref   handler
	.word  handler
	.endm

SYSCALL_NI .macro
	.ref   sys_ni_syscall
	.word  sys_ni_syscall
	.endm
	
SYSCALL_LOCAL .macro handler
	.word  handler
	.endm

	.sect 	".data"
	.align 32
_sys_call_table:
	SYSCALL_NI				; 0
	SYSCALL_ENTRY	sys_exit
	SYSCALL_LOCAL	sys_fork
	SYSCALL_ENTRY	sys_read
	SYSCALL_ENTRY	sys_write
	SYSCALL_ENTRY	sys_open
	SYSCALL_ENTRY	sys_close
	SYSCALL_ENTRY	sys_waitpid
	SYSCALL_ENTRY	sys_creat
	SYSCALL_ENTRY	sys_link
	SYSCALL_ENTRY	sys_unlink		; 10
	SYSCALL_LOCAL	sys_execve
	SYSCALL_ENTRY	sys_chdir
	SYSCALL_ENTRY	sys_time
	SYSCALL_ENTRY	sys_mknod
	SYSCALL_ENTRY	sys_chmod
	SYSCALL_ENTRY	sys_chown16
	SYSCALL_NI
	SYSCALL_ENTRY	sys_stat
	SYSCALL_ENTRY	sys_lseek
	SYSCALL_ENTRY	sys_getpid		; 20
	SYSCALL_ENTRY	sys_mount
	SYSCALL_ENTRY	sys_oldumount
	SYSCALL_ENTRY	sys_setuid16
	SYSCALL_ENTRY	sys_getuid16
	SYSCALL_ENTRY	sys_stime
	SYSCALL_ENTRY	sys_ptrace
	SYSCALL_ENTRY	sys_alarm
	SYSCALL_ENTRY	sys_fstat
	SYSCALL_ENTRY	sys_pause
	SYSCALL_ENTRY	sys_utime		; 30
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_access
	SYSCALL_ENTRY	sys_nice
	SYSCALL_NI
	SYSCALL_ENTRY	sys_sync
	SYSCALL_ENTRY	sys_kill
	SYSCALL_ENTRY	sys_rename
	SYSCALL_ENTRY	sys_mkdir
	SYSCALL_ENTRY	sys_rmdir		; 40
	SYSCALL_ENTRY	sys_dup
	SYSCALL_ENTRY	sys_pipe
	SYSCALL_ENTRY	sys_times
	SYSCALL_NI
	SYSCALL_ENTRY	sys_brk
	SYSCALL_ENTRY	sys_setgid16
	SYSCALL_ENTRY	sys_getgid16
	SYSCALL_ENTRY	sys_signal
	SYSCALL_ENTRY	sys_geteuid16
	SYSCALL_ENTRY	sys_getegid16		; 50
	SYSCALL_ENTRY	sys_acct
	SYSCALL_ENTRY	sys_umount
	SYSCALL_NI
	SYSCALL_ENTRY	sys_ioctl
	SYSCALL_ENTRY	sys_fcntl
	SYSCALL_NI
	SYSCALL_ENTRY	sys_setpgid
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_umask		; 60
	SYSCALL_ENTRY	sys_chroot
	SYSCALL_ENTRY	sys_ustat
	SYSCALL_ENTRY	sys_dup2
	SYSCALL_ENTRY	sys_getppid
	SYSCALL_ENTRY	sys_getpgrp
	SYSCALL_ENTRY	sys_setsid
	SYSCALL_ENTRY	sys_sigaction
	SYSCALL_ENTRY	sys_sgetmask
	SYSCALL_ENTRY	sys_ssetmask
	SYSCALL_ENTRY	sys_setreuid16		; 70
	SYSCALL_ENTRY	sys_setregid16
	SYSCALL_LOCAL	sys_sigsuspend
	SYSCALL_ENTRY	sys_sigpending
	SYSCALL_ENTRY	sys_sethostname
	SYSCALL_ENTRY	sys_setrlimit
	SYSCALL_ENTRY	sys_old_getrlimit
	SYSCALL_ENTRY	sys_getrusage
	SYSCALL_ENTRY	sys_gettimeofday
	SYSCALL_ENTRY	sys_settimeofday
	SYSCALL_ENTRY	sys_getgroups16		; 80
	SYSCALL_ENTRY	sys_setgroups16
	SYSCALL_ENTRY	old_select
	SYSCALL_ENTRY	sys_symlink
	SYSCALL_ENTRY	sys_lstat
	SYSCALL_ENTRY	sys_readlink
	SYSCALL_ENTRY	sys_uselib
	SYSCALL_ENTRY	sys_swapon
	SYSCALL_ENTRY	sys_reboot
	SYSCALL_ENTRY	sys_old_readdir
	SYSCALL_ENTRY	old_mmap		; 90
	SYSCALL_ENTRY	sys_munmap
	SYSCALL_ENTRY	sys_truncate
	SYSCALL_ENTRY	sys_ftruncate
	SYSCALL_ENTRY	sys_fchmod
	SYSCALL_ENTRY	sys_fchown16
	SYSCALL_ENTRY	sys_getpriority
	SYSCALL_ENTRY	sys_setpriority
	SYSCALL_NI
	SYSCALL_ENTRY	sys_statfs
	SYSCALL_ENTRY	sys_fstatfs		; 100
	SYSCALL_ENTRY	sys_ioperm
	SYSCALL_ENTRY	sys_socketcall
	SYSCALL_ENTRY	sys_syslog
	SYSCALL_ENTRY	sys_setitimer
	SYSCALL_ENTRY	sys_getitimer
	SYSCALL_ENTRY	sys_newstat
	SYSCALL_ENTRY	sys_newlstat
	SYSCALL_ENTRY	sys_newfstat
	SYSCALL_NI
	SYSCALL_NI				; 110
	SYSCALL_ENTRY	sys_vhangup
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_wait4
	SYSCALL_ENTRY	sys_swapoff
	SYSCALL_ENTRY	sys_sysinfo
	SYSCALL_ENTRY	sys_ipc
	SYSCALL_ENTRY	sys_fsync
	SYSCALL_LOCAL	sys_sigreturn
	SYSCALL_LOCAL	sys_clone		; 120
	SYSCALL_ENTRY	sys_setdomainname
	SYSCALL_ENTRY	sys_newuname
	SYSCALL_ENTRY	sys_cacheflush
	SYSCALL_ENTRY	sys_adjtimex
	SYSCALL_NI
	SYSCALL_ENTRY	sys_sigprocmask
	SYSCALL_NI
	SYSCALL_ENTRY	sys_init_module
	SYSCALL_ENTRY	sys_delete_module
	SYSCALL_NI				; 130
	SYSCALL_ENTRY	sys_quotactl
	SYSCALL_ENTRY	sys_getpgid
	SYSCALL_ENTRY	sys_fchdir
	SYSCALL_ENTRY	sys_bdflush
	SYSCALL_ENTRY	sys_sysfs
	SYSCALL_ENTRY	sys_personality
	SYSCALL_NI
	SYSCALL_ENTRY	sys_setfsuid16
	SYSCALL_ENTRY	sys_setfsgid16
	SYSCALL_ENTRY	sys_llseek		; 140
	SYSCALL_ENTRY	sys_getdents
	SYSCALL_ENTRY	sys_select
	SYSCALL_ENTRY	sys_flock
	SYSCALL_NI
	SYSCALL_ENTRY	sys_readv
	SYSCALL_ENTRY	sys_writev
	SYSCALL_ENTRY	sys_getsid
	SYSCALL_ENTRY	sys_fdatasync
	SYSCALL_ENTRY	sys_sysctl
	SYSCALL_NI				; 150
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_sched_setparam
	SYSCALL_ENTRY	sys_sched_getparam
	SYSCALL_ENTRY	sys_sched_setscheduler
	SYSCALL_ENTRY	sys_sched_getscheduler
	SYSCALL_ENTRY	sys_sched_yield
	SYSCALL_ENTRY	sys_sched_get_priority_max
	SYSCALL_ENTRY	sys_sched_get_priority_min	; 160
	SYSCALL_ENTRY	sys_sched_rr_get_interval
	SYSCALL_ENTRY	sys_nanosleep
	SYSCALL_NI
	SYSCALL_ENTRY	sys_setresuid16
	SYSCALL_ENTRY	sys_getresuid16
	SYSCALL_ENTRY	sys_getpagesize
	SYSCALL_NI
	SYSCALL_ENTRY	sys_poll
	SYSCALL_ENTRY	sys_nfsservctl
	SYSCALL_ENTRY	sys_setresgid16		; 170
	SYSCALL_ENTRY	sys_getresgid16
	SYSCALL_ENTRY	sys_prctl
	SYSCALL_LOCAL	sys_rt_sigreturn
	SYSCALL_ENTRY	sys_rt_sigaction
	SYSCALL_ENTRY	sys_rt_sigprocmask
	SYSCALL_ENTRY	sys_rt_sigpending
	SYSCALL_ENTRY	sys_rt_sigtimedwait
	SYSCALL_ENTRY	sys_rt_sigqueueinfo
	SYSCALL_LOCAL	sys_rt_sigsuspend
	SYSCALL_LOCAL	sys_pread_c6x		; 180
	SYSCALL_LOCAL	sys_pwrite_c6x
	SYSCALL_ENTRY	sys_lchown16
	SYSCALL_ENTRY	sys_getcwd
	SYSCALL_ENTRY	sys_capget
	SYSCALL_ENTRY	sys_capset
	SYSCALL_ENTRY	sys_sigaltstack
	SYSCALL_ENTRY	sys_sendfile
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_LOCAL	sys_vfork		; 190
	SYSCALL_ENTRY	sys_getrlimit
	SYSCALL_ENTRY	sys_mmap_pgoff
	SYSCALL_LOCAL	sys_truncate64_c6x
	SYSCALL_LOCAL	sys_ftruncate64_c6x
	SYSCALL_ENTRY	sys_stat64
	SYSCALL_ENTRY	sys_lstat64
	SYSCALL_ENTRY	sys_fstat64
	SYSCALL_ENTRY	sys_chown
	SYSCALL_ENTRY	sys_getuid
	SYSCALL_ENTRY	sys_getgid		; 200
	SYSCALL_ENTRY	sys_geteuid
	SYSCALL_ENTRY	sys_getegid
	SYSCALL_ENTRY	sys_setreuid
	SYSCALL_ENTRY	sys_setregid
	SYSCALL_ENTRY	sys_getgroups
	SYSCALL_ENTRY	sys_setgroups
	SYSCALL_ENTRY	sys_fchown
	SYSCALL_ENTRY	sys_setresuid
	SYSCALL_ENTRY	sys_getresuid
	SYSCALL_ENTRY	sys_setresgid		; 210
	SYSCALL_ENTRY	sys_getresgid
	SYSCALL_ENTRY	sys_lchown
	SYSCALL_ENTRY	sys_setuid
	SYSCALL_ENTRY	sys_setgid
	SYSCALL_ENTRY	sys_setfsuid
	SYSCALL_ENTRY	sys_setfsgid
	SYSCALL_ENTRY	sys_pivot_root
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_getdents64		; 220
	SYSCALL_ENTRY	sys_gettid
	SYSCALL_ENTRY	sys_tkill
	SYSCALL_ENTRY	sys_setxattr
	SYSCALL_ENTRY	sys_lsetxattr
	SYSCALL_ENTRY	sys_fsetxattr
	SYSCALL_ENTRY	sys_getxattr
	SYSCALL_ENTRY	sys_lgetxattr
	SYSCALL_ENTRY	sys_fgetxattr
	SYSCALL_ENTRY	sys_listxattr
	SYSCALL_ENTRY	sys_llistxattr		; 230
	SYSCALL_ENTRY	sys_flistxattr
	SYSCALL_ENTRY	sys_removexattr
	SYSCALL_ENTRY	sys_lremovexattr
	SYSCALL_ENTRY	sys_fremovexattr
	SYSCALL_ENTRY	sys_futex
	SYSCALL_ENTRY	sys_sendfile64
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_fcntl64
	SYSCALL_ENTRY	sys_readahead		; 240
	SYSCALL_ENTRY	sys_io_setup
	SYSCALL_ENTRY	sys_io_destroy
	SYSCALL_ENTRY	sys_io_getevents
	SYSCALL_ENTRY	sys_io_submit
	SYSCALL_ENTRY	sys_io_cancel
	SYSCALL_ENTRY	sys_fadvise64
	SYSCALL_ENTRY	sys_exit_group
	SYSCALL_ENTRY	sys_lookup_dcookie
	SYSCALL_ENTRY	sys_epoll_create
	SYSCALL_ENTRY	sys_epoll_ctl		; 250
	SYSCALL_ENTRY	sys_epoll_wait
	SYSCALL_NI
	SYSCALL_ENTRY	sys_set_tid_address
	SYSCALL_ENTRY	sys_timer_create
	SYSCALL_ENTRY	sys_timer_settime
	SYSCALL_ENTRY	sys_timer_gettime
	SYSCALL_ENTRY	sys_timer_getoverrun
	SYSCALL_ENTRY	sys_timer_delete
	SYSCALL_ENTRY	sys_clock_settime
	SYSCALL_ENTRY	sys_clock_gettime	; 260
	SYSCALL_ENTRY	sys_clock_getres
	SYSCALL_ENTRY	sys_clock_nanosleep
	SYSCALL_ENTRY	sys_statfs64
	SYSCALL_ENTRY	sys_fstatfs64
	SYSCALL_ENTRY	sys_tgkill
	SYSCALL_ENTRY	sys_utimes
	SYSCALL_ENTRY	sys_fadvise64_64
	SYSCALL_ENTRY	sys_mbind
	SYSCALL_ENTRY	sys_get_mempolicy
	SYSCALL_ENTRY	sys_set_mempolicy	; 270
	SYSCALL_ENTRY	sys_mq_open
	SYSCALL_ENTRY	sys_mq_unlink
	SYSCALL_ENTRY	sys_mq_timedsend
	SYSCALL_ENTRY	sys_mq_timedreceive
	SYSCALL_ENTRY	sys_mq_notify
	SYSCALL_ENTRY	sys_mq_getsetattr
	SYSCALL_ENTRY	sys_waitid
	SYSCALL_NI
	SYSCALL_ENTRY	sys_add_key
	SYSCALL_ENTRY	sys_request_key		; 280
	SYSCALL_ENTRY	sys_keyctl
	SYSCALL_NI
	SYSCALL_NI
	SYSCALL_ENTRY	sys_sched_setaffinity
	SYSCALL_ENTRY	sys_sched_getaffinity
	SYSCALL_NI
	SYSCALL_ENTRY	sys_ioprio_set
	SYSCALL_ENTRY	sys_ioprio_get
	SYSCALL_ENTRY	sys_inotify_add_watch
	SYSCALL_ENTRY	sys_inotify_rm_watch    ; 290
	SYSCALL_ENTRY	sys_openat
	SYSCALL_ENTRY	sys_mkdirat
	SYSCALL_ENTRY	sys_mknodat
	SYSCALL_ENTRY	sys_fchownat
	SYSCALL_ENTRY	sys_fstatat64
	SYSCALL_ENTRY	sys_unlinkat
	SYSCALL_ENTRY	sys_renameat
	SYSCALL_ENTRY	sys_linkat
	SYSCALL_ENTRY	sys_symlinkat
	SYSCALL_ENTRY	sys_readlinkat		; 300
	SYSCALL_ENTRY	sys_fchmodat
	SYSCALL_ENTRY	sys_faccessat
	SYSCALL_ENTRY	sys_pselect6
	SYSCALL_ENTRY	sys_ppoll
	SYSCALL_ENTRY	sys_unshare
	SYSCALL_ENTRY	sys_set_robust_list
	SYSCALL_ENTRY	sys_get_robust_list
	SYSCALL_ENTRY	sys_splice
	SYSCALL_ENTRY	sys_sync_file_range
	SYSCALL_ENTRY	sys_tee			; 310
	SYSCALL_ENTRY	sys_vmsplice
	SYSCALL_ENTRY	sys_getcpu
	SYSCALL_ENTRY	sys_epoll_pwait
	SYSCALL_ENTRY	sys_utimensat
	SYSCALL_ENTRY	sys_timerfd_create
	SYSCALL_LOCAL	sys_fallocate_c6x
	SYSCALL_ENTRY	sys_timerfd_settime
	SYSCALL_ENTRY	sys_timerfd_gettime
	SYSCALL_ENTRY	sys_signalfd4
	SYSCALL_ENTRY	sys_eventfd2		; 320
	SYSCALL_ENTRY	sys_epoll_create1
	SYSCALL_ENTRY	sys_dup3
	SYSCALL_ENTRY	sys_pipe2
	SYSCALL_ENTRY	sys_inotify_init1
	SYSCALL_ENTRY	sys_preadv
	SYSCALL_ENTRY	sys_pwritev
	SYSCALL_ENTRY	sys_rt_tgsigqueueinfo
	SYSCALL_ENTRY	sys_perf_event_open
	SYSCALL_ENTRY	sys_recvmmsg
	SYSCALL_ENTRY	sys_cache_sync	; 330

